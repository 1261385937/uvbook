<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Networking &mdash; An Introduction to libuv</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="An Introduction to libuv" href="index.html" />
    <link rel="next" title="Threads" href="threads.html" />
    <link rel="prev" title="Filesystem" href="filesystem.html" />
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33699076-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>An Introduction to libuv</span></a></h1>
        <h2 class="heading"><span>Networking</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="filesystem.html">Filesystem</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="threads.html">Threads</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="networking">
<h1>Networking<a class="headerlink" href="#networking" title="Permalink to this headline">¶</a></h1>
<p>Networking in libuv is not much different from directly using the BSD socket
interface, some things are easier, all are non-blocking, but the concepts stay
the same. In addition libuv offers utility functions to abstract the annoying,
repetitive and low-level tasks like setting up sockets using the BSD socket
structures, DNS lookup, and tweaking various socket parameters.</p>
<p>The <code class="docutils literal"><span class="pre">uv_tcp_t</span></code> and <code class="docutils literal"><span class="pre">uv_udp_t</span></code> structures are used for network I/O.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The code samples in this chapter exist to show certain libuv APIs. They are
not examples of good quality code. They leak memory and don&#8217;t always close
connections properly.</p>
</div>
<div class="section" id="tcp">
<h2>TCP<a class="headerlink" href="#tcp" title="Permalink to this headline">¶</a></h2>
<p>TCP is a connection oriented, stream protocol and is therefore based on the
libuv streams infrastructure.</p>
<div class="section" id="server">
<h3>Server<a class="headerlink" href="#server" title="Permalink to this headline">¶</a></h3>
<p>Server sockets proceed by:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">uv_tcp_init</span></code> the TCP handle.</li>
<li><code class="docutils literal"><span class="pre">uv_tcp_bind</span></code> it.</li>
<li>Call <code class="docutils literal"><span class="pre">uv_listen</span></code> on the handle to have a callback invoked whenever a new
connection is established by a client.</li>
<li>Use <code class="docutils literal"><span class="pre">uv_accept</span></code> to accept the connection.</li>
<li>Use <a class="reference internal" href="filesystem.html#buffers-and-streams"><span>stream operations</span></a> to communicate with the
client.</li>
</ol>
<p>Here is a simple echo server</p>
<p class="rubric">tcp-echo-server/main.c - The listen socket</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

<span class="hll">    <span class="n">uv_tcp_t</span> <span class="n">server</span><span class="p">;</span>
</span><span class="hll">    <span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">);</span>
</span>
<span class="hll">    <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="n">DEFAULT_PORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>
</span><span class="hll">
</span><span class="hll">    <span class="n">uv_tcp_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="hll">    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">uv_listen</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">server</span><span class="p">,</span> <span class="n">DEFAULT_BACKLOG</span><span class="p">,</span> <span class="n">on_new_connection</span><span class="p">);</span>
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Listen error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>You can see the utility function <code class="docutils literal"><span class="pre">uv_ip4_addr</span></code> being used to convert from
a human readable IP address, port pair to the sockaddr_in structure required by
the BSD socket APIs. The reverse can be obtained using <code class="docutils literal"><span class="pre">uv_ip4_name</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There are <code class="docutils literal"><span class="pre">uv_ip6_*</span></code> analogues for the ip4 functions.</p>
</div>
<p>Most of the setup functions are synchronous since they are CPU-bound.
<code class="docutils literal"><span class="pre">uv_listen</span></code> is where we return to libuv&#8217;s callback style. The second
arguments is the backlog queue &#8211; the maximum length of queued connections.</p>
<p>When a connection is initiated by clients, the callback is required to set up
a handle for the client socket and associate the handle using <code class="docutils literal"><span class="pre">uv_accept</span></code>.
In this case we also establish interest in reading from this stream.</p>
<p class="rubric">tcp-echo-server/main.c - Accepting the client</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre>
<span class="kt">void</span> <span class="nf">on_new_connection</span><span class="p">(</span><span class="n">uv_stream_t</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;New connection error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_strerror</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
        <span class="c1">// error!</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

<span class="hll">    <span class="n">uv_tcp_t</span> <span class="o">*</span><span class="n">client</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_tcp_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_tcp_t</span><span class="p">));</span>
</span><span class="hll">    <span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">client</span><span class="p">);</span>
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">uv_accept</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="p">(</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uv_read_start</span><span class="p">((</span><span class="n">uv_stream_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="n">alloc_buffer</span><span class="p">,</span> <span class="n">echo_read</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">client</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The remaining set of functions is very similar to the streams example and can
be found in the code. Just remember to call <code class="docutils literal"><span class="pre">uv_close</span></code> when the socket isn&#8217;t
required. This can be done even in the <code class="docutils literal"><span class="pre">uv_listen</span></code> callback if you are not
interested in accepting the connection.</p>
</div>
<div class="section" id="client">
<h3>Client<a class="headerlink" href="#client" title="Permalink to this headline">¶</a></h3>
<p>Where you do bind/listen/accept on the server, on the client side it&#8217;s simply
a matter of calling <code class="docutils literal"><span class="pre">uv_tcp_connect</span></code>. The same <code class="docutils literal"><span class="pre">uv_connect_cb</span></code> style
callback of <code class="docutils literal"><span class="pre">uv_listen</span></code> is used by <code class="docutils literal"><span class="pre">uv_tcp_connect</span></code>. Try:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">uv_tcp_t</span><span class="o">*</span> <span class="n">socket</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_tcp_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_tcp_t</span><span class="p">));</span>
<span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">socket</span><span class="p">);</span>

<span class="n">uv_connect_t</span><span class="o">*</span> <span class="n">connect</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_connect_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_connect_t</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">dest</span><span class="p">;</span>
<span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dest</span><span class="p">);</span>

<span class="n">uv_tcp_connect</span><span class="p">(</span><span class="n">connect</span><span class="p">,</span> <span class="n">socket</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dest</span><span class="p">,</span> <span class="n">on_connect</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">on_connect</span></code> will be called after the connection is established. The
callback receives the <code class="docutils literal"><span class="pre">uv_connect_t</span></code> struct, which has a member <code class="docutils literal"><span class="pre">.handle</span></code>
pointing to the socket.</p>
</div>
</div>
<div class="section" id="udp">
<h2>UDP<a class="headerlink" href="#udp" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/User_Datagram_Protocol">User Datagram Protocol</a> offers connectionless, unreliable network
communication. Hence libuv doesn&#8217;t offer a stream. Instead libuv provides
non-blocking UDP support via the <cite>uv_udp_t</cite> handle (for receiving) and
<cite>uv_udp_send_t</cite> request (for sending) and related functions. That said, the
actual API for reading/writing is very similar to normal stream reads. To look
at how UDP can be used, the example shows the first stage of obtaining an IP
address from a <a class="reference external" href="http://tools.ietf.org/html/rfc2131">DHCP</a> server &#8211; DHCP Discover.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You will have to run <cite>udp-dhcp</cite> as <strong>root</strong> since it uses well known port
numbers below 1024.</p>
</div>
<p class="rubric">udp-dhcp/main.c - Setup and send UDP packets</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre>
<span class="n">uv_loop_t</span> <span class="o">*</span><span class="n">loop</span><span class="p">;</span>
<span class="n">uv_udp_t</span> <span class="n">send_socket</span><span class="p">;</span>
<span class="n">uv_udp_t</span> <span class="n">recv_socket</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>
<span class="hll">
</span>    <span class="n">uv_udp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_socket</span><span class="p">);</span>
<span class="hll">    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">recv_addr</span><span class="p">;</span>
</span><span class="hll">    <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="mi">68</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_addr</span><span class="p">);</span>
</span>    <span class="n">uv_udp_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_socket</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">recv_addr</span><span class="p">,</span> <span class="n">UV_UDP_REUSEADDR</span><span class="p">);</span>
    <span class="n">uv_udp_recv_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">recv_socket</span><span class="p">,</span> <span class="n">alloc_buffer</span><span class="p">,</span> <span class="n">on_read</span><span class="p">);</span>

    <span class="n">uv_udp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_socket</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">broadcast_addr</span><span class="p">;</span>
<span class="hll">    <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s">&quot;0.0.0.0&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">broadcast_addr</span><span class="p">);</span>
</span><span class="hll">    <span class="n">uv_udp_bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">send_socket</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">broadcast_addr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span>    <span class="n">uv_udp_set_broadcast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">send_socket</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="hll">    <span class="n">uv_udp_send_t</span> <span class="n">send_req</span><span class="p">;</span>
</span>    <span class="n">uv_buf_t</span> <span class="n">discover_msg</span> <span class="o">=</span> <span class="n">make_discover_msg</span><span class="p">();</span>

    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">send_addr</span><span class="p">;</span>
    <span class="n">uv_ip4_addr</span><span class="p">(</span><span class="s">&quot;255.255.255.255&quot;</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_addr</span><span class="p">);</span>
    <span class="n">uv_udp_send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">send_req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_socket</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">discover_msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">send_addr</span><span class="p">,</span> <span class="n">on_send</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The IP address <code class="docutils literal"><span class="pre">0.0.0.0</span></code> is used to bind to all interfaces. The IP
address <code class="docutils literal"><span class="pre">255.255.255.255</span></code> is a broadcast address meaning that packets
will be sent to all interfaces on the subnet.  port <code class="docutils literal"><span class="pre">0</span></code> means that the OS
randomly assigns a port.</p>
</div>
<p>First we setup the receiving socket to bind on all interfaces on port 68 (DHCP
client) and start a read on it. This will read back responses from any DHCP
server that replies. We use the UV_UDP_REUSEADDR flag to play nice with any
other system DHCP clients that are running on this computer on the same port.
Then we setup a similar send socket and use <code class="docutils literal"><span class="pre">uv_udp_send</span></code> to send
a <em>broadcast message</em> on port 67 (DHCP server).</p>
<p>It is <strong>necessary</strong> to set the broadcast flag, otherwise you will get an
<code class="docutils literal"><span class="pre">EACCES</span></code> error <a class="footnote-reference" href="#id5" id="id1">[1]</a>. The exact message being sent is not relevant to this
book and you can study the code if you are interested. As usual the read and
write callbacks will receive a status code of &lt; 0 if something went wrong.</p>
<p>Since UDP sockets are not connected to a particular peer, the read callback
receives an extra parameter about the sender of the packet.</p>
<p><code class="docutils literal"><span class="pre">nread</span></code> may be zero if there is no more data to be read. If <code class="docutils literal"><span class="pre">addr</span></code> is NULL,
it indicates there is nothing to read (the callback shouldn&#8217;t do anything), if
not NULL, it indicates that an empty datagram was received from the host at
<code class="docutils literal"><span class="pre">addr</span></code>. The <code class="docutils literal"><span class="pre">flags</span></code> parameter may be <code class="docutils literal"><span class="pre">UV_UDP_PARTIAL</span></code> if the buffer
provided by your allocator was not large enough to hold the data. <em>In this case
the OS will discard the data that could not fit</em> (That&#8217;s UDP for you!).</p>
<p class="rubric">udp-dhcp/main.c - Reading packets</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span class="hll"><span class="kt">void</span> <span class="nf">on_read</span><span class="p">(</span><span class="n">uv_udp_t</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">nread</span><span class="p">,</span> <span class="k">const</span> <span class="n">uv_buf_t</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Read error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">nread</span><span class="p">));</span>
        <span class="n">uv_close</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">req</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="n">sender</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">uv_ip4_name</span><span class="p">((</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr_in</span><span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">,</span> <span class="n">sender</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Recv from %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sender</span><span class="p">);</span>

    <span class="c1">// ... DHCP specific code</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">as_integer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ipbin</span> <span class="o">=</span> <span class="n">ntohl</span><span class="p">(</span><span class="n">as_integer</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ip</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">ip</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipbin</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Offered IP %d.%d.%d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ip</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">ip</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
<span class="hll">    <span class="n">uv_udp_recv_stop</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
</span><span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="udp-options">
<h3>UDP Options<a class="headerlink" href="#udp-options" title="Permalink to this headline">¶</a></h3>
<div class="section" id="time-to-live">
<h4>Time-to-live<a class="headerlink" href="#time-to-live" title="Permalink to this headline">¶</a></h4>
<p>The TTL of packets sent on the socket can be changed using <code class="docutils literal"><span class="pre">uv_udp_set_ttl</span></code>.</p>
</div>
<div class="section" id="ipv6-stack-only">
<h4>IPv6 stack only<a class="headerlink" href="#ipv6-stack-only" title="Permalink to this headline">¶</a></h4>
<p>IPv6 sockets can be used for both IPv4 and IPv6 communication. If you want to
restrict the socket to IPv6 only, pass the <code class="docutils literal"><span class="pre">UV_UDP_IPV6ONLY</span></code> flag to
<code class="docutils literal"><span class="pre">uv_udp_bind</span></code> <a class="footnote-reference" href="#id6" id="id2">[2]</a>.</p>
</div>
<div class="section" id="multicast">
<h4>Multicast<a class="headerlink" href="#multicast" title="Permalink to this headline">¶</a></h4>
<p>A socket can (un)subscribe to a multicast group using:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">UV_EXTERN</span> <span class="kt">int</span> <span class="nf">uv_udp_set_membership</span><span class="p">(</span><span class="n">uv_udp_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span>
                                    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">multicast_addr</span><span class="p">,</span>
                                    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">interface_addr</span><span class="p">,</span>
                                    <span class="n">uv_membership</span> <span class="n">membership</span><span class="p">);</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">membership</span></code> is <code class="docutils literal"><span class="pre">UV_JOIN_GROUP</span></code> or <code class="docutils literal"><span class="pre">UV_LEAVE_GROUP</span></code>.</p>
<p>The concepts of multicasting are nicely explained in <a class="reference external" href="http://www.tldp.org/HOWTO/Multicast-HOWTO-2.html">this guide</a>.</p>
<p>Local loopback of multicast packets is enabled by default <a class="footnote-reference" href="#id7" id="id3">[3]</a>, use
<code class="docutils literal"><span class="pre">uv_udp_set_multicast_loop</span></code> to switch it off.</p>
<p>The packet time-to-live for multicast packets can be changed using
<code class="docutils literal"><span class="pre">uv_udp_set_multicast_ttl</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="querying-dns">
<h2>Querying DNS<a class="headerlink" href="#querying-dns" title="Permalink to this headline">¶</a></h2>
<p>libuv provides asynchronous DNS resolution. For this it provides its own
<code class="docutils literal"><span class="pre">getaddrinfo</span></code> replacement <a class="footnote-reference" href="#id8" id="id4">[4]</a>. In the callback you can
perform normal socket operations on the retrieved addresses. Let&#8217;s connect to
Freenode to see an example of DNS resolution.</p>
<p class="rubric">dns/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">uv_default_loop</span><span class="p">();</span>

    <span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">;</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">PF_INET</span><span class="p">;</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_protocol</span> <span class="o">=</span> <span class="n">IPPROTO_TCP</span><span class="p">;</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">uv_getaddrinfo_t</span> <span class="n">resolver</span><span class="p">;</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;irc.freenode.net is... &quot;</span><span class="p">);</span>
<span class="hll">    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">uv_getaddrinfo</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resolver</span><span class="p">,</span> <span class="n">on_resolved</span><span class="p">,</span> <span class="s">&quot;irc.freenode.net&quot;</span><span class="p">,</span> <span class="s">&quot;6667&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">);</span>
</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;getaddrinfo call error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">uv_run</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">UV_RUN_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>If <code class="docutils literal"><span class="pre">uv_getaddrinfo</span></code> returns non-zero, something went wrong in the setup and
your callback won&#8217;t be invoked at all. All arguments can be freed immediately
after <code class="docutils literal"><span class="pre">uv_getaddrinfo</span></code> returns. The <cite>hostname</cite>, <cite>servname</cite> and <cite>hints</cite>
structures are documented in <a class="reference external" href="getaddrinfo">the getaddrinfo man page</a>. The
callback can be <code class="docutils literal"><span class="pre">NULL</span></code> in which case the function will run synchronously.</p>
<p>In the resolver callback, you can pick any IP from the linked list of <code class="docutils literal"><span class="pre">struct</span>
<span class="pre">addrinfo(s)</span></code>. This also demonstrates <code class="docutils literal"><span class="pre">uv_tcp_connect</span></code>. It is necessary to
call <code class="docutils literal"><span class="pre">uv_freeaddrinfo</span></code> in the callback.</p>
<p class="rubric">dns/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">on_resolved</span><span class="p">(</span><span class="n">uv_getaddrinfo_t</span> <span class="o">*</span><span class="n">resolver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;getaddrinfo callback error %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uv_err_name</span><span class="p">(</span><span class="n">status</span><span class="p">));</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="n">addr</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;\0&#39;</span><span class="p">};</span>
<span class="hll">    <span class="n">uv_ip4_name</span><span class="p">((</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="o">*</span><span class="p">)</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
</span>    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

    <span class="n">uv_connect_t</span> <span class="o">*</span><span class="n">connect_req</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_connect_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_connect_t</span><span class="p">));</span>
    <span class="n">uv_tcp_t</span> <span class="o">*</span><span class="n">socket</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv_tcp_t</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv_tcp_t</span><span class="p">));</span>
    <span class="n">uv_tcp_init</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">socket</span><span class="p">);</span>

    <span class="n">uv_tcp_connect</span><span class="p">(</span><span class="n">connect_req</span><span class="p">,</span> <span class="n">socket</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">on_connect</span><span class="p">);</span>
<span class="hll">
</span>    <span class="n">uv_freeaddrinfo</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

</pre></div>
</td></tr></table></div>
<p>libuv also provides the inverse <a class="reference external" href="http://docs.libuv.org/en/v1.x/dns.html#c.uv_getnameinfo">uv_getnameinfo</a>.</p>
</div>
<div class="section" id="network-interfaces">
<h2>Network interfaces<a class="headerlink" href="#network-interfaces" title="Permalink to this headline">¶</a></h2>
<p>Information about the system&#8217;s network interfaces can be obtained through libuv
using <code class="docutils literal"><span class="pre">uv_interface_addresses</span></code>. This simple program just prints out all the
interface details so you get an idea of the fields that are available. This is
useful to allow your service to bind to IP addresses when it starts.</p>
<p class="rubric">interfaces/main.c</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;uv.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
    <span class="n">uv_interface_address_t</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

<span class="hll">    <span class="n">uv_interface_addresses</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
</span>    <span class="n">i</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Number of interfaces: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uv_interface_address_t</span> <span class="n">interface</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Name: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">interface</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="hll">        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Internal? %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">interface</span><span class="p">.</span><span class="n">is_internal</span> <span class="o">?</span> <span class="s">&quot;Yes&quot;</span> <span class="o">:</span> <span class="s">&quot;No&quot;</span><span class="p">);</span>
</span>        
        <span class="k">if</span> <span class="p">(</span><span class="n">interface</span><span class="p">.</span><span class="n">address</span><span class="p">.</span><span class="n">address4</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">uv_ip4_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="p">.</span><span class="n">address</span><span class="p">.</span><span class="n">address4</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;IPv4 address: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">interface</span><span class="p">.</span><span class="n">address</span><span class="p">.</span><span class="n">address4</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">uv_ip6_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface</span><span class="p">.</span><span class="n">address</span><span class="p">.</span><span class="n">address6</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;IPv6 address: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">uv_free_interface_addresses</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><code class="docutils literal"><span class="pre">is_internal</span></code> is true for loopback interfaces. Note that if a physical
interface has multiple IPv4/IPv6 addresses, the name will be reported multiple
times, with each address being reported once.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://beej.us/guide/bgnet/output/html/multipage/advanced.html#broadcast">http://beej.us/guide/bgnet/output/html/multipage/advanced.html#broadcast</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>on Windows only supported on Windows Vista and later.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://www.tldp.org/HOWTO/Multicast-HOWTO-6.html#ss6.1">http://www.tldp.org/HOWTO/Multicast-HOWTO-6.html#ss6.1</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>libuv use the system <code class="docutils literal"><span class="pre">getaddrinfo</span></code> in the libuv threadpool. libuv
v0.8.0 and earlier also included <a class="reference external" href="http://c-ares.haxx.se">c-ares</a> as an alternative, but this has been
removed in v0.9.0.</td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="filesystem.html">Filesystem</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="threads.html">Threads</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012-2014, Nikhil Marathe.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
  </body>
</html>